<!DOCTYPE html><script type="module">
import App, { Colour } from "./fungi/App.js";
import Ease  from "./fungi/maths/Easing.js";
import XhrQueue		from "./fungi/lib/XhrQueue.js";
//import Capsule	from "../../fungi/geo/Capsule.js";
//import Points 	from "../../fungi/geo/Points.js";
//import Motion 	from "../../fungi.test/Motion.js";
import UVSphere		from "./fungi/geo/UVSphere.js";
import PropPanel	from "./sage.ui/PropPanel.js";

//#####################################################
App
	.init()
	//.load_shaders( "LowPoly.js" )
	.set_camera( 10, 10, 2, 0, 0.5, 0 )
	.task( init )
	.then();

let gPnt, gMotion, gUbo, $mat;

//#####################################################

function on_render( dt, ss ){
	//if( dt ) gMotion( dt ); // Move Point
	//App.ubo.update( gUbo.set( "pos", gPnt.node.local.pos ) );
}

async function init( ){	
	let img	= await XhrQueue.url( "../files/textures/", 
		"noise_clouds_01.png",
	).then();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	/* Shader */
	init_shader();

	let tex0	= App.texture.new( "noise_cloud", img );
	$mat		= App.shader.new_material( "TESTER", { 
		heightmap_tex : tex0,
	});

	let e = UVSphere( "Eye", $mat, 18, 25, 0.5, true, true );
	e.node.set_pos( 0, 0.6, 0 );
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	/* Show Light Location
	gPnt = Points.new_entity( "Light" );
	gPnt.points.add( [0,0,0], "#ffffff", 0.3, 1 );
	gPnt.node.set_pos( 4, 1.8, 5 );
	*/

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	/* Motion Closure for Point
	gMotion = Motion.circle( gPnt, 0.5, 3, 2 );
	*/

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	init_ui();
	on_render();
	//App.render_by( 1, on_render );
	return true;
}

//#####################################################

function init_shader(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	gUbo = App.ubo.new( "Light", 10, [
		{ name:"pos",	type:"vec3" },
		{ name:"color",	type:"vec3" },
	]);

	gUbo
		.set( "pos", [ 2, 5, 1 ] )
		.set( "color", Colour.rgb_array( "#ffffff" ) );
	App.ubo.update( gUbo );
	
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

	App.shader.new( "TESTER", VERT_SRC, FRAG_SRC, [
		{ name:"eye_color", type:"rgb", value:"#ffffff" },
		{ name:"eye_shadow", type:"rgb", value:"#6666CB" },
		{ name:"iris_color_a", type:"rgb", value:"#fae125" },
		{ name:"iris_color_b", type:"rgb", value:"#ff6f00" },
		{ name:"edge_color", type:"rgb", value:"#000000" },
		{ name:"heightmap_tex",	type:"sampler2D", value:"null" },
		{ name:"iris_radius", type:"float", value:0.35 },
		{ name:"edge_size", type:"float", value:0.15 },
		{ name:"pupil_radius", type:"float", value:0.2 },
		{ name:"pupil_scl", type:"vec2", value:new Float32Array( [6.0, 1.0] ) },
		{ name:"iris_scl", type:"vec2", value:new Float32Array( [1.0, 1.0] ) },
	], App.ubo.get_array( "Global", "Model", "Light" ) );
}

// https://www.patreon.com/posts/quick-game-art-29141036
// https://pastebin.com/6LrRnwV4
// https://pastebin.com/uj4fJk0j
// https://www.patreon.com/posts/shader-graph-32245563

// https://www.patreon.com/posts/quick-game-art-13059579 Toon Specular
// https://github.com/LadTy/ParallaxGlitter Parallax Glitter Effect

const VERT_SRC = `#version 300 es
	layout(location=0) in vec3 a_pos;
	layout(location=1) in vec3 a_norm;
	
	//-------------------------

	uniform Global{ 
		mat4 proj_view; 
		mat4 camera_matrix;
		vec3 camera_pos;
		float delta_time;
		vec2 screen_size;
		float clock;
	} global;

	uniform Model{ 
		mat4 view_matrix;
	} model;

	//-------------------------

	out vec3 frag_norm;
	out vec3 frag_cam;
	out vec3 frag_wpos;
	out vec3 frag_lpos;

	//-------------------------

	void main(void){
		vec4 wpos	= model.view_matrix * vec4( a_pos, 1.0 );

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		frag_lpos 		= a_pos.xyz;
		frag_wpos		= wpos.xyz;
		frag_cam		= global.camera_pos;
		frag_norm 		= mat3( transpose( inverse( model.view_matrix ) ) ) * a_norm; // Need to Rotate and Scale Normal, do on CPU

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		gl_Position = global.proj_view * wpos;
		gl_PointSize = 8.0;
	}`;

const FRAG_SRC = `#version 300 es
	precision mediump float;
	
	out vec4 out_color;

	//-------------------------
	
	uniform Light{ 
		vec3 pos;
		vec3 color;
	} light;

	uniform sampler2D heightmap_tex;

	uniform vec3 iris_color_a;
	uniform vec3 iris_color_b;

	uniform float iris_radius; // 0.35;
	uniform float edge_size; // 0.15;
	uniform float pupil_radius; // 0.2;
	uniform vec2 pupil_scl;	//vec2( 6.0, 1.0 );
	uniform vec2 iris_scl;	//vec2( 1.0, 1.0 );

	uniform vec3 eye_color;
	uniform vec3 eye_shadow;
	uniform vec3 edge_color;

	uniform vec3 specular_color;
	uniform vec3 rim_color;

	in vec3 frag_norm;
	in vec3 frag_cam;
	in vec3 frag_wpos;
	in vec3 frag_lpos;

	//-------------------------
	// Parallax Code Provided : Doesn't Seem to work Well
	// h = parallaxStrength, height from Height Map.
	vec2 parallax_offset( float h, float height, vec3 viewDir ){
		h 		= h * height * height / 2.0;
		vec3 v	= normalize( viewDir );
		v.z		+= 0.42;
		return h * ( v.xy / v.z );
	}

	// Parallax from Shader Nodes, Ported to Code : Works much better
	vec2 parallax_uv( float p_strength, float height, vec3 view_dir, vec2 uv ){
		float a	= ((p_strength + 0.5) * height) - ( height / 2.0 );
		vec3 v	= normalize( view_dir );
		v.z		+= 0.42;
		return a * ( v.xy / v.z ) + uv;
	}

	float step_ramp( float t, float step_val[5], float step_pos[5], float feather, int i ){
		for( i; i > 0; i-- ){
			if( (step_pos[ i ]-feather) <= t ){
				return mix( 
					step_val[ i-1 ], 
					step_val[ i ],
					smoothstep( step_pos[ i ] - feather, step_pos[ i ] + feather, t )
				);
			}
		}
		return step_val[ 0 ];
	}

	//-------------------------

	void main( void ){
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		vec3 norm 		= normalize( frag_norm );				// Must normalized, Since it has been interpolated
		vec3 dir_light	= normalize( light.pos - frag_wpos );	// Frag to Light Directiom
		vec3 dir_cam	= normalize( frag_cam - frag_wpos );	// Frag tp Camera Direction

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// New Fragment local position, shifting closer to origin on Z Axis
		// This way frags that are z=0.5 will have a length of 0, moving closer
		// to 1 when world space z == 0.

		vec3 fpos			= vec3( frag_lpos.xy, frag_lpos.z - 0.5 );
		vec2 uv				= vec2( -frag_lpos.x , -frag_lpos.y );
		float lite_ratio	= clamp( dot( norm, dir_light ) * 0.5 + 0.5, 0.0, 1.0 ); 
        
		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// IRIS
		//const float iris_radius		= 0.35;
		//const vec2	iris_scl		= vec2( 1.0, 1.0 );
		
		float iris_len	= length( fpos * vec3( iris_scl, 1.0 ) ); // w->b
		float iris_rng	= iris_len / iris_radius; // w->b
		float iris_grad	= 1.0 - clamp( iris_rng, 0.0, 1.0 ); // b->w
		float iris_mask	= clamp( iris_grad * 20.0, 0.0, 1.0 );

		//out_color.rgb = vec3( iris_mask );

		// Parallax Texture
		vec2 iris_uv	= ( uv / 0.8 ) + 0.5;					// Center UV					
		vec4 hmap_px	= texture( heightmap_tex, iris_uv );	// Height Map
		
		//vec2 para_uv	= parallax_offset( 2.0, hmap_px.r, dir_cam ) + iris_uv;	// From Code
		vec2 para_uv	= parallax_uv( 0.6, hmap_px.r, dir_cam, iris_uv );		// From Shader Nodes
		vec4 iris_px	= texture( heightmap_tex, para_uv );	// Reuse as Texure Map

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// IRIS EDGE
		//const float edge_size	= 0.15;

		float edge_grad			= 1.0 - clamp( iris_rng - edge_size, 0.0, 1.0 );
		float edge_mask			= clamp( edge_grad * 30.0, 0.0, 1.0 );

		// Cut Hole in Edge Circle, Both does the same thing but second one simpler
		//float edge_ring_mask	= edge_mask * ( 1.0 - iris_mask );
		float edge_ring_mask	= edge_mask - iris_mask;

		//out_color.rgb = vec3( edge_ring_mask );

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// PUPIL

		//const float pupil_radius	= 0.2;
		//const vec2	pupil_scl		= vec2( 6.0, 1.0 );

		float pupil_len		= length( fpos * vec3( pupil_scl, 1.0 ) ); // w->b
		float pupil_rng		= pupil_len / pupil_radius;
		float pupil_grad	= 1.0 - clamp( pupil_rng, 0.0, 1.0 );
		float pupil_mask	= clamp( pupil_grad * 20.0, 0.0, 1.0 );

		//out_color.rgb = vec3( iris_mask );
		//out_color.rgb = vec3( pupil_mask );
		//out_color.rgb = vec3( iris_mask - pupil_mask );

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // SPECULAR
		
		/* Original
		float specu = dot( norm, normalize( dir_light + dir_cam ) ) * 0.5;
		specu = step( 0.48, specu );
		*/

		/* Standard */
		const float specular_strength	= 5.0;
		const float shininess 			= 32.0;

		vec3 dir_reflect	= reflect( -dir_light, norm );				// Reflection Dir of Fragment to Light
		vec3 dir_frag_cam	= normalize( frag_cam - frag_lpos );		// Dir from Fragment to Camera
        float specu 		= specular_strength * pow( max( dot( dir_frag_cam, dir_reflect ), 0.0 ), shininess );

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// COLORING

		// GRADIENT MAP
		float step_val[5]	= float[]( 0.65, 0.70, 0.9, 0.0, 0.0 );
		float step_pos[5]	= float[]( 0.0, 0.15, 0.4, 9.0, 9.0 );
		float ramp			= step_ramp( lite_ratio, step_val, step_pos, 0.02, 2 );

		//-------------------
		// MAIN
		vec3 eye_c	= mix( eye_shadow, eye_color, ramp ) * ( 1.0 - edge_mask );

		//-------------------
		// IRIS
		//vec3 iris_c = mix( iris_color_a, iris_color_b, iris_grad ) ;	// Bled by Iris Gradient
		vec3 iris_c	= mix( iris_color_a, iris_color_b, hmap_px.r * 1.1 ); // Blend color based on Hitemap
		
		// Cut pupil circle out of iris circle,  Then Apply Iris Texture
		iris_c		*= (iris_mask - pupil_mask) * ( iris_px.rgb * 1.7 ) ;

		//-------------------
		// EDGE
		vec3 edge_c = edge_color * edge_ring_mask;

		//-------------------
		// PUPIL
		vec3 pupil_c = mix( vec3( .25, 0.0, 0.0 ), vec3( 0.0, 0.0, 0.0), pupil_grad );
		pupil_c *= pupil_mask;

		//-------------------
		// MERGE
		out_color.rgb = eye_c + 					// Eye color has ramp shading
			( iris_c + pupil_c + edge_c ) * ramp + 	// Use ramp to Shadow the non-eye parts
			vec3( 1.0 ) * specu;					// Throw in some specular glare
	}`;


/*
ORIGINAL UNITY SHADER BY MINIONART

Shader "Custom/ProcEye"
{
    Properties
    {
		[Header(Main)]
        _Color ("Color", Color) = (1,1,1,1)
      
		[Header(Iris)]
		_IrisTex("Iris Texture (RGB)", 2D) = "white" {}
		_IrisTexColor("Iris Texture Tint", Color) = (1,0,0,1)
		_Radius("Iris Radius", Range(0,1)) = 0.4
		_IrisColor("Iris Color", Color) = (0,1,1,1)
		_IrisColorOut("Iris Color Out", Color) = (0,1,0,1)
		_IrisScaleX("Iris Scale X", Range(0,2)) = 1
		_IrisScaleY("Iris Scale Y", Range(0,2)) = 1
		_Speed("Iris Scroll Speed", Range(-10,10)) = 0
		_Scale("Iris Texture Scale", Range(0.1,10)) = 10
		[Toggle(TEXTURE)] _TEXTURE("Circlular Texture", Float) = 0
		_Distort("Iris Texture Distortion", Range(0,1)) = 0.5

		[Header(Pupil)]	 	
		_RadiusPupil("Pupil Radius", Range(0,0.5)) = 0.1
		_PupilColor("Pupil Color", Color) = (0,0,0,1)
		_PupilColorOut("Pupil Color Out", Color) = (0,0,1,1)
		_PupilScaleX("Pupil Scale X", Range(0,1)) = 0.5
		_PupilScaleY("Pupil Scale Y", Range(0,1)) = 0.5

		[Header(Specular and Iris Edge)]
		_Edgewidth("Iris Edge Width", Range(0,2)) = 0.1
		_SpecSize("Specular Size", Range(0.2,0.5)) = 0.47
		_IrisEdgeColor("Iris Edge Color", Color) = (0,0,0,1)
					
		
	}
		SubShader
		{
			Tags { "RenderType" = "Opaque" }
			LOD 200
		  CGPROGRAM
        // Physically based Standard lighting model, and enable shadows on all light types
        #pragma surface surf  Standard fullforwardshadows vertex:vert
        #pragma target 3.5
      
		#pragma shader_feature TEXTURE

		sampler2D _MainTex, _IrisTex;
        struct Input
        {
            float2 uv_MainTex;
			float3 objPos;
			float3 lightDir;
			float3 viewDir;
        };

 
		float _Radius, _RadiusPupil;
        fixed4 _Color, _IrisColor, _PupilColor, _PupilColorOut, _IrisColorOut, _IrisTexColor, _IrisEdgeColor;
		float _PupilScaleX, _PupilScaleY, _Edgewidth, _SpecSize, _IrisScaleX, _IrisScaleY, _Scale, _Speed, _Distort;
		

		void vert(inout appdata_full v, out Input o) {
			UNITY_INITIALIZE_OUTPUT(Input, o);
			o.objPos = v.vertex;
			o.lightDir = WorldSpaceLightDir(v.vertex); // get the worldspace lighting direction
		}

        // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.
        // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.
        // #pragma instancing_options assumeuniformscaling
        UNITY_INSTANCING_BUFFER_START(Props)
            // put more per-instance properties here
        UNITY_INSTANCING_BUFFER_END(Props)

        void surf (Input IN, inout SurfaceOutputStandard o)
        {
     
			// circles
			float dis= distance(0, float3(IN.objPos.x * _IrisScaleX, IN.objPos.y * _IrisScaleY, IN.objPos.z - 0.5)); 
			float disPup = (distance(0, float3(IN.objPos.x * _PupilScaleX, IN.objPos.y * _PupilScaleY , IN.objPos.z - 0.5))); 
			float irisRadius = 1- saturate(dis / _Radius);
			float pupilRadius = 1 - saturate(disPup / _RadiusPupil);
			float irisEdge = 1 - saturate(dis / _Radius - _Edgewidth);
		
			// specular
			half d = dot(o.Normal, normalize(IN.lightDir + IN.viewDir))*0.5;
			d = step(_SpecSize, d);
			
			
			// Iris texture
			float4 i = tex2D(_IrisTex, IN.uv_MainTex);

			float speed = _Time.x * _Speed + (_Distort *i);

#if TEXTURE
			// circular
			i = tex2D(_IrisTex, float2((irisRadius * IN.uv_MainTex + speed) * _Scale) ) ;
#else
			// normal
			i =tex2D(_IrisTex, (float2(IN.uv_MainTex.x, IN.uv_MainTex.y + speed)  * _Scale) ) * _Color;
#endif
			// add extra tint
			i *= _IrisTexColor;


			// increase strength then clamp it for a smooth circle
			float irisCircle = saturate(irisRadius * 20);
			float pupilCircle = saturate(pupilRadius * 20);
			float irisEdgeCircle = saturate(irisEdge * 20);
			
			// eyewhite is everything but the iris 
			float4 eyeWhite = _Color * (1 - irisEdgeCircle);

			// subract to avoid bleeding through of colors
			irisEdgeCircle -= irisCircle;
			irisCircle -= pupilCircle;

			// lerp colors
			float4 irisLerp = lerp(_IrisColorOut,_IrisColor, irisRadius ) + i;
			float4 irisColored = irisCircle * irisLerp;
		
			float4 pupilLerp = lerp(_PupilColorOut,_PupilColor, pupilRadius);
			float4 pupilColored = pupilCircle * pupilLerp;

			float4 irisEdgeColored = irisEdgeCircle * _IrisEdgeColor;

			// all together
			o.Albedo = eyeWhite + irisColored + pupilColored + irisEdgeColored;

			// specular in emission
			o.Emission = d;

        }
        ENDCG
    }
    FallBack "Diffuse"
}


Shader "Custom/ProcEye Textured"
{
    Properties
    {
		[Header(Main)]
        _Color ("Color", Color) = (1,1,1,1)
      
		[Header(Iris)]
		_IrisTex("Iris Texture (RGB)", 2D) = "black" {}
		_IrisTexColor("Iris Texture Tint", Color) = (1,0,0,1)
		_Radius("Iris Radius", Range(0,1)) = 0.4
		_IrisColor("Iris Color", Color) = (0,1,1,1)
		_IrisColorOut("Iris Color Out", Color) = (0,1,0,1)
		_IrisScaleX("Iris Scale X", Range(0,2)) = 1
		_IrisScaleY("Iris Scale Y", Range(0,2)) = 1
		_Speed("Iris Scroll Speed", Range(-10,10)) = 0
		_Scale("Iris Texture Scale", Range(0.1,10)) = 10
		[Toggle(TEXTURE)] _TEXTURE("Circlular Texture", Float) = 0
		_Distort("Iris Texture Distortion", Range(0,1)) = 0.5
		_Brightness("Iris Texture Brigthness", Range(0,5)) = 1

		[Header(Pupil)]	 	
		_PupilTex("Pupil Texture (RGB)", 2D) = "white" {}
		_PupilScale("Pupil Tex Radius", Range(0,1)) = 0.3
		_RadiusPupil("Pupil Radius", Range(0,0.5)) = 0.1
		_PupilColor("Pupil Color", Color) = (0,0,0,1)
		_PupilColorOut("Pupil Color Out", Color) = (0,0,1,1)
		_PupilScaleX("Pupil Scale X", Range(0,1)) = 0.5
		_PupilScaleY("Pupil Scale Y", Range(0,1)) = 0.5

		[Header(Highlight and Iris Edge)]
		_GlintTex("Glint Texture (RGB)", 2D) = "black" {}
		_GlintScale("Glint Scale", Range(0,1)) = 0.3
		_Edgewidth("Iris Edge Width", Range(0,2)) = 0.1
		_IrisEdgeColor("Iris Edge Color", Color) = (0,0,0,1)
					
		
	}
		SubShader
		{
			Tags { "RenderType" = "Opaque" }
			LOD 200
		  CGPROGRAM
        // Physically based Standard lighting model, and enable shadows on all light types
        #pragma surface surf  Standard fullforwardshadows vertex:vert
        #pragma target 3.5
      
		#pragma shader_feature TEXTURE

		sampler2D _MainTex, _IrisTex, _PupilTex, _GlintTex;
        struct Input
        {
            float2 uv_MainTex;
			float4 objPos;
			float3 viewDir;
        };

 
		float _Radius, _RadiusPupil;
        fixed4 _Color, _IrisColor, _PupilColor, _PupilColorOut, _IrisColorOut, _IrisTexColor, _IrisEdgeColor;
		float _PupilScaleX, _PupilScaleY, _Edgewidth, _IrisScaleX, _IrisScaleY, _Scale, _Speed, _Distort, _Brightness;
		float _PupilScale;
		float  _GlintScale;

		void vert(inout appdata_full v, out Input o) {
			UNITY_INITIALIZE_OUTPUT(Input, o);
			o.objPos = v.vertex;
		}

        // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.
        // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.
        // #pragma instancing_options assumeuniformscaling
        UNITY_INSTANCING_BUFFER_START(Props)
            // put more per-instance properties here
        UNITY_INSTANCING_BUFFER_END(Props)

        void surf (Input IN, inout SurfaceOutputStandard o)
        {


			// circles
			float dis= distance(0, float3(IN.objPos.x * _IrisScaleX, IN.objPos.y * _IrisScaleY, IN.objPos.z - 0.5)); 
			float disPup = (distance(0, float3(IN.objPos.x * _PupilScaleX, IN.objPos.y * _PupilScaleY , IN.objPos.z - 0.5))); 
			float irisRadius = 1- saturate(dis / _Radius);
			float pupilRadius = 1 - saturate(disPup / _RadiusPupil);
			float irisEdge = 1 - saturate(dis / _Radius - _Edgewidth);
		
			// point in center of eye, flipped
			float2 uv = float2(-IN.objPos.x , IN.objPos.y );
			// uv for the pupil, adjusted for a sphere
			float2 uvPup  = uv / (_PupilScale * 2);
			uvPup += 0.5;
			
			// uv for the glint, adjusted for a sphere
			float2 uvGlint = uv / (_GlintScale * 2);
			uvGlint += 0.5;
			uvGlint.x -= 0.2;
			uvGlint += IN.viewDir * 0.2;

		
			
			// Iris texture
			float4 i = tex2D(_IrisTex, IN.uv_MainTex);

			float speed = _Time.x * _Speed + (_Distort *i);

#if TEXTURE
			// circular
			i = tex2D(_IrisTex, float2((disPup * IN.uv_MainTex + speed) * _Scale) ) ;
#else
			// normal
			i =tex2D(_IrisTex, (float2(IN.uv_MainTex.x, IN.uv_MainTex.y + speed)  * _Scale) );
#endif

			// glint and pupil texture
			float4 glint = tex2D(_GlintTex, uvGlint);
			float4 pup = tex2D(_PupilTex, uvPup);

			// add extra tint
			i *= _IrisTexColor;
			i *= _Brightness;

			// increase strength then clamp it for a smooth circle
			float irisCircle = saturate(irisRadius * 20);
			float pupilCircle = saturate(pupilRadius * 20);
			pupilCircle *= pup.r;
			float irisEdgeCircle = saturate(irisEdge * 10);
			
			// eyewhite is everything but the iris 
			float4 eyeWhite = _Color * (1 - irisEdgeCircle);
			glint *= irisCircle;
			// subract to avoid bleeding through of colors
			irisEdgeCircle -=irisCircle ;
		
			irisCircle -= pupilCircle;

			// lerp colors
			float4 irisLerp = lerp(_IrisColorOut,_IrisColor, irisRadius ) + i;
			float4 irisColored = irisCircle * irisLerp;
		
			float4 pupilLerp = lerp(_PupilColorOut,_PupilColor, pupilRadius);
			float4 pupilColored = pupilCircle * pupilLerp;


			float4 irisEdgeColored = irisEdgeCircle * _IrisEdgeColor;
		
			// all together
			o.Albedo = eyeWhite + irisColored + pupilColored + irisEdgeColored;
			// glint in emission
			o.Emission =  glint;
			o.Smoothness = 0.75;


        }
        ENDCG
    }
    FallBack "Diffuse"
}
*/


//#####################################################

function init_ui(){
	elm_on_input( "iris_radius" );
	elm_on_input( "edge_size" );
	elm_on_input( "pupil_radius" );
	v2_on_input( "pupil_scl_x", "pupil_scl_y", "pupil_scl" );
	v2_on_input( "iris_scl_x", "iris_scl_y", "iris_scl" );
}

function update_mat( n, v ){ $mat.set( n, v ); App.render(); }
function elm_on_input( name ){
	document.getElementById( name ).addEventListener( "input", (e)=>{
		update_mat( e.srcElement.id, parseFloat( e.srcElement.value ) );
	});
}
function v2_on_input( a, b, n ){
	let aa = document.getElementById( a );
	let bb = document.getElementById( b );

	let fn = (e)=>{
		let v = new Float32Array([
			parseFloat( aa.value ),
			parseFloat( bb.value ),
		]);
		update_mat( n, v );
	}

	aa.addEventListener( "input", fn );
	bb.addEventListener( "input", fn );
}


</script>
<html><head><style>html,body{ margin:0px; padding:0px; width:100%; height:100%; }
.lnk{ position:absolute; bottom:5px; left:5px; color:yellow; text-decoration:none; font-family:monospace; }
</style></head><body><canvas id="pg_canvas"></canvas>
	<a href="https://www.patreon.com/posts/quick-game-art-29141036" class="lnk">Ported From MinionsArt : https://www.patreon.com/posts/quick-game-art-29141036</a>

	<prop-panel id="PntProp" side="right" width="300px" class="Theme" open="true" top="10px">
		<prop-group label="Iris" open="true">
			<prop-range label="Radius" id="iris_radius" value="0.35" min="0.15" max=".5" step="0.01"></prop-range>
			<prop-range label="Edge" id="edge_size" value="0.15" min="0.03" max=".5" step="0.01"></prop-range>

			<prop-range label="XScale" id="iris_scl_x" value="1" min=".2" max="7" step="0.1"></prop-range>
			<prop-range label="YScale" id="iris_scl_y" value="1" min=".2" max="7" step="0.1"></prop-range>
		</prop-group>

		<prop-group label="Pupil" open="true">
			<prop-range label="Radius" id="pupil_radius" value="0.2" min="0.04" max=".4" step="0.01"></prop-range>
			<prop-range label="XScale" id="pupil_scl_x" value="6" min=".5" max="7" step="0.1"></prop-range>
			<prop-range label="YScale" id="pupil_scl_y" value="1" min=".5" max="7" step="0.1"></prop-range>
		</prop-group>
	</prop-panel>
</body></html>